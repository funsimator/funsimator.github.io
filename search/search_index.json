{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Portfolio Henry Hinsberger \u00b6 Willkommen auf meinem Portfolio! Hier finden Sie einen \u00dcberblick meiner Projekte , F\u00e4higkeiten und Interessen . Meine Name ist Henry Hinsberger und ich komme aus Kirchseeon bei M\u00fcnchen. 2019 hab ich mein Abitur gemacht und studiere seit 2020 an der Hochschule Kempten im Informatik nahen Studiengang \"Game-Engineering\" . Meine Interessen liegen im Bereich \"Interaktive Medien\" insbesondere Game-Design . Zus\u00e4tzlich habe ich Spa\u00df an den technischen Hintergr\u00fcnden, vom Programmieren bis zur Hardware. Portfolio \u00b6 Hier bekommen Sie einen schnellen Einblick \u00fcber ausgew\u00e4hlte Projekte, die ich umgesetzt oder an denen ich beteiligt war. Falls Sie ein Projekt n\u00e4her interesSiert, gibt es zu jedem Eintrag weitere Links. Daten \u00b6 Generell Aktuell Noten Kontakt Alter: 21 Jahre Semester: 4 Abitur Note: 2,6 Kontakt: henry@lahnorange.de Wohnort: Kempten Studiengang: Game-Engineering Aktueller Notenschnitt: 2,7 Erfahrungen \u00b6 Hier finden Sie die wichtigsten Bereiche, in denen ich schon Erfahrungen gesammelt habe. Die Listen sind nach Wissensstand sortiert. Programmiersprachen Engines Animation und Video Sonstige Software 1. C++ 1. Unity 1. Blender Visual Studio 2. C# 2. Unreal 2. Lightworks Git 3. OpenGLSL 3. Vektoria MS Office 4. Java Krita","title":"Willkommen"},{"location":"#portfolio-henry-hinsberger","text":"Willkommen auf meinem Portfolio! Hier finden Sie einen \u00dcberblick meiner Projekte , F\u00e4higkeiten und Interessen . Meine Name ist Henry Hinsberger und ich komme aus Kirchseeon bei M\u00fcnchen. 2019 hab ich mein Abitur gemacht und studiere seit 2020 an der Hochschule Kempten im Informatik nahen Studiengang \"Game-Engineering\" . Meine Interessen liegen im Bereich \"Interaktive Medien\" insbesondere Game-Design . Zus\u00e4tzlich habe ich Spa\u00df an den technischen Hintergr\u00fcnden, vom Programmieren bis zur Hardware.","title":"Portfolio Henry Hinsberger"},{"location":"#portfolio","text":"Hier bekommen Sie einen schnellen Einblick \u00fcber ausgew\u00e4hlte Projekte, die ich umgesetzt oder an denen ich beteiligt war. Falls Sie ein Projekt n\u00e4her interesSiert, gibt es zu jedem Eintrag weitere Links.","title":"Portfolio"},{"location":"#daten","text":"Generell Aktuell Noten Kontakt Alter: 21 Jahre Semester: 4 Abitur Note: 2,6 Kontakt: henry@lahnorange.de Wohnort: Kempten Studiengang: Game-Engineering Aktueller Notenschnitt: 2,7","title":"Daten"},{"location":"#erfahrungen","text":"Hier finden Sie die wichtigsten Bereiche, in denen ich schon Erfahrungen gesammelt habe. Die Listen sind nach Wissensstand sortiert. Programmiersprachen Engines Animation und Video Sonstige Software 1. C++ 1. Unity 1. Blender Visual Studio 2. C# 2. Unreal 2. Lightworks Git 3. OpenGLSL 3. Vektoria MS Office 4. Java Krita","title":"Erfahrungen"},{"location":"Abitur/","text":"","title":"Abitur"},{"location":"Achensee/","text":"Animations-Projekt \"Mikado-Tower\" \u00b6 Das Animations-Projekt \"Mikado-Tower\" ist Teil eines Extremsport-Videos, das aus realen Aufnahmen und computeranimierten Szenen besteht. Die animierten Teile wurden von mir mit Blender erstellt, um m\u00f6glichst nahtlose \u00dcberg\u00e4nge zu den Aufnahmen zu erm\u00f6glichen. Die Umgebung wurde mit Hilfe eines Plugins, aus Satellitendaten erstellt. Der \"Mikado-Tower\" in Blender Der Springer bei einem Salto vorw\u00e4rts Das fertige Video \u00b6","title":"3. Animations-Projekt \"Mikado Tower\""},{"location":"Achensee/#animations-projekt-mikado-tower","text":"Das Animations-Projekt \"Mikado-Tower\" ist Teil eines Extremsport-Videos, das aus realen Aufnahmen und computeranimierten Szenen besteht. Die animierten Teile wurden von mir mit Blender erstellt, um m\u00f6glichst nahtlose \u00dcberg\u00e4nge zu den Aufnahmen zu erm\u00f6glichen. Die Umgebung wurde mit Hilfe eines Plugins, aus Satellitendaten erstellt. Der \"Mikado-Tower\" in Blender Der Springer bei einem Salto vorw\u00e4rts","title":"Animations-Projekt \"Mikado-Tower\""},{"location":"Achensee/#das-fertige-video","text":"","title":"Das fertige Video"},{"location":"Args/","text":"Args Kata \u00b6 Link zur Kata hier . Schritt 1: Schema definieren \u00b6 Damit der Parser sp\u00e4ter die gegebenen Strings verifizieren kann muss erst mal eine Syntax f\u00fcr die Schemata festgelegt werden, die unserem Parser sagen, welche Formen der Input haben darf. Das Schema muss f\u00fcr jedes Flag den Name und den Type enthalten. Mein Schema habe ich so festgelegt, dass immer jeweils in einer Zeile der Name im Format \"-X\" , wobei X genau ein Buchstabe sein darf. In der n\u00e4chsten Zeile steht dann der Value-Type, repr\u00e4sentiert durch genau einen Buchstaben. es gibt die Typen: i (integer), f (float), b (boolean), n (null/none) f\u00fcr komplexere Typen kann s (string) mit zus\u00e4tzlichem regul\u00e4ren Ausdruck benutzt werden Ein Beispielfile Schema.txt k\u00f6nnte dann so aussehen: -a f -q i Regul\u00e4re Ausdr\u00fccke \u00b6 Regul\u00e4re Ausdr\u00fccke sind eine formale M\u00f6glichkeit zu definieren, welche W\u00f6rter von einer Grammatik akzeptiert werden. Das kann f\u00fcr uns sehr hilfreich sein. Zus\u00e4tzlich k\u00f6nnen wir damit alle noch so komplizierten Arten von Input beschreiben. Regul\u00e4re Ausdr\u00fccke sehen so aus: (a-z | 0-9)* @ (a-z)* \\. (a-z)* (x)* : Beliebige Anzahl an x-en auch 0 (x)+ : Beliebige Anzahl an x-en nicht 0 [x] : Optionales Zeichen Falls du Regul\u00e4re Ausdr\u00fccke noch nicht kennst hier eine einfache Erkl\u00e4rung . Die tats\u00e4chliche Syntax kann sich je nach Implementierung unterscheiden. (C++ benutzt standardm\u00e4\u00dfig ECMA-Script ) Umsetzung \u00b6 Es ist sehr hilfreich die Funktionen die ganze Zeit ausgiebig zu testen, da es sehr viele verschiedene Kombinationen zu beachten gibt. Sinnvolle Fehlermeldungen sind dabei genauso wichtig! Schritt 2: Schema Parser \u00b6 Zuerst brauchen wir eine Parser, der das Schema-file einlesen kann und uns die verschiedenen Flags gut formatiert ablegt. Der Parser sollte erst \u00fcberpr\u00fcfen, ob der Name des Flags das korrekte Format hat, dann ob es einen g\u00fcltigen Typ hat und beides danach in einem Vector ablegen. In der L\u00f6sung machen dass die Funktionen: bool CheckFlagName(string name) und bool CheckFlagValue(string name) . Um die Flags des Schemas zu speichern bietet es sich an einen Vektor zu verwenden. Schritt 3: Command Parser \u00b6 Als n\u00e4chstes brauchen wir nat\u00fcrlich den Parser, der die eigentlichen Kommandos bekommt und diese auf die G\u00fcltigkeit \u00fcberpr\u00fcft. Dieser sollte \u00e4hnlich dem Schema Parser zuerst \u00dcberpr\u00fcfen, ob der Name des Flags in dem Schema vorgesehen ist und danach ob der Type richtig ist. Bei mir sind das die Funktionen, auto CheckFlagName(const vector<string>&vec,string flag) und bool CheckFlagValueType(string entry,string& value) . Da f\u00fcr unterschiedliche Typen unterschiedliche Formate m\u00f6glich sind, habe ich die Individuellen \u00dcberpr\u00fcfungen in eigene Funktionen mit der Signatur TYPE CheckForTYPE(string flag) ausgelagert. Diese k\u00f6nnen auch sp\u00e4ter wiederverwendet werden, um den Wert des Flags zu bekommen. Nach der \u00dcberpr\u00fcfung sollten die Werte wieder in einem Vector gespeichert werden. Beachte: falls f\u00fcr ein Flag kein Wert angegeben wurde soll ein geeigneter Default-Wert ausgegeben werden. Schritt 4: Werte Abrufen \u00b6 Als letztes muss es noch eine M\u00f6glichkeit geben, die gespeicherten Werte abzufragen. Daf\u00fcr bieten sich Template-Funktionen an, die die vorherige TYPE CheckForTYPE(string flag) Funktion nutzen um den Wert des entsprechenden Flags auszugeben. Bei mir sind das die Template-Spezialisierungen mit der Signatur: template<class Type> Type GetFlag(string flag) . Im Prinzip muss man bei allen drei Vorg\u00e4ngen, \u00e4hnliche Schritte durchgehen.","title":"Args Kata"},{"location":"Args/#args-kata","text":"Link zur Kata hier .","title":"Args Kata"},{"location":"Args/#schritt-1-schema-definieren","text":"Damit der Parser sp\u00e4ter die gegebenen Strings verifizieren kann muss erst mal eine Syntax f\u00fcr die Schemata festgelegt werden, die unserem Parser sagen, welche Formen der Input haben darf. Das Schema muss f\u00fcr jedes Flag den Name und den Type enthalten. Mein Schema habe ich so festgelegt, dass immer jeweils in einer Zeile der Name im Format \"-X\" , wobei X genau ein Buchstabe sein darf. In der n\u00e4chsten Zeile steht dann der Value-Type, repr\u00e4sentiert durch genau einen Buchstaben. es gibt die Typen: i (integer), f (float), b (boolean), n (null/none) f\u00fcr komplexere Typen kann s (string) mit zus\u00e4tzlichem regul\u00e4ren Ausdruck benutzt werden Ein Beispielfile Schema.txt k\u00f6nnte dann so aussehen: -a f -q i","title":"Schritt 1: Schema definieren"},{"location":"Args/#regulare-ausdrucke","text":"Regul\u00e4re Ausdr\u00fccke sind eine formale M\u00f6glichkeit zu definieren, welche W\u00f6rter von einer Grammatik akzeptiert werden. Das kann f\u00fcr uns sehr hilfreich sein. Zus\u00e4tzlich k\u00f6nnen wir damit alle noch so komplizierten Arten von Input beschreiben. Regul\u00e4re Ausdr\u00fccke sehen so aus: (a-z | 0-9)* @ (a-z)* \\. (a-z)* (x)* : Beliebige Anzahl an x-en auch 0 (x)+ : Beliebige Anzahl an x-en nicht 0 [x] : Optionales Zeichen Falls du Regul\u00e4re Ausdr\u00fccke noch nicht kennst hier eine einfache Erkl\u00e4rung . Die tats\u00e4chliche Syntax kann sich je nach Implementierung unterscheiden. (C++ benutzt standardm\u00e4\u00dfig ECMA-Script )","title":"Regul\u00e4re Ausdr\u00fccke"},{"location":"Args/#umsetzung","text":"Es ist sehr hilfreich die Funktionen die ganze Zeit ausgiebig zu testen, da es sehr viele verschiedene Kombinationen zu beachten gibt. Sinnvolle Fehlermeldungen sind dabei genauso wichtig!","title":"Umsetzung"},{"location":"Args/#schritt-2-schema-parser","text":"Zuerst brauchen wir eine Parser, der das Schema-file einlesen kann und uns die verschiedenen Flags gut formatiert ablegt. Der Parser sollte erst \u00fcberpr\u00fcfen, ob der Name des Flags das korrekte Format hat, dann ob es einen g\u00fcltigen Typ hat und beides danach in einem Vector ablegen. In der L\u00f6sung machen dass die Funktionen: bool CheckFlagName(string name) und bool CheckFlagValue(string name) . Um die Flags des Schemas zu speichern bietet es sich an einen Vektor zu verwenden.","title":"Schritt 2: Schema Parser"},{"location":"Args/#schritt-3-command-parser","text":"Als n\u00e4chstes brauchen wir nat\u00fcrlich den Parser, der die eigentlichen Kommandos bekommt und diese auf die G\u00fcltigkeit \u00fcberpr\u00fcft. Dieser sollte \u00e4hnlich dem Schema Parser zuerst \u00dcberpr\u00fcfen, ob der Name des Flags in dem Schema vorgesehen ist und danach ob der Type richtig ist. Bei mir sind das die Funktionen, auto CheckFlagName(const vector<string>&vec,string flag) und bool CheckFlagValueType(string entry,string& value) . Da f\u00fcr unterschiedliche Typen unterschiedliche Formate m\u00f6glich sind, habe ich die Individuellen \u00dcberpr\u00fcfungen in eigene Funktionen mit der Signatur TYPE CheckForTYPE(string flag) ausgelagert. Diese k\u00f6nnen auch sp\u00e4ter wiederverwendet werden, um den Wert des Flags zu bekommen. Nach der \u00dcberpr\u00fcfung sollten die Werte wieder in einem Vector gespeichert werden. Beachte: falls f\u00fcr ein Flag kein Wert angegeben wurde soll ein geeigneter Default-Wert ausgegeben werden.","title":"Schritt 3: Command Parser"},{"location":"Args/#schritt-4-werte-abrufen","text":"Als letztes muss es noch eine M\u00f6glichkeit geben, die gespeicherten Werte abzufragen. Daf\u00fcr bieten sich Template-Funktionen an, die die vorherige TYPE CheckForTYPE(string flag) Funktion nutzen um den Wert des entsprechenden Flags auszugeben. Bei mir sind das die Template-Spezialisierungen mit der Signatur: template<class Type> Type GetFlag(string flag) . Im Prinzip muss man bei allen drei Vorg\u00e4ngen, \u00e4hnliche Schritte durchgehen.","title":"Schritt 4: Werte Abrufen"},{"location":"Conway/","text":"Game of Life Kata \u00b6 Link zur Kata hier . Bei der Game of Life Kata geht es darum, Conways \"Game of Life\" nachzuprogrammieren, einen Startzustand laden zu k\u00f6nnen und den n\u00e4chsten Zustand wieder abspeichern zu k\u00f6nnen. Das \"Game of Life\" ist ein spezifischer Zellul\u00e4rer Automat , also kurzgesagt ein 2-Dimensionales (nicht zwingend) Feld aus Zellen, die bin\u00e4r entweder tot (0) oder lebendig (1) sind. Zus\u00e4tzlich haben zellul\u00e4rer Automaten eine Regel, die festlegt, welchen Zustand die Zelle im n\u00e4chsten Schritt haben wird. Diese Regel ist immer abh\u00e4ngig von den Nachbarn einer Zelle. Conways Game of Life \u00b6 Das \"Game of Life\" hat seinen Namen daher, dass die Regel des Automaten ein Ergebnis liefert, dass stark an die Bewegung und Entwicklung von kleinen mehrzelligen Organismen erinnert. Es gibt sich wiederholende, sich bewegende und konstante Muster. Die Regeln des \"Game of Life\" sind ganz einfach: Eine tote Zelle mit genau drei lebenden Nachbarn wird im n\u00e4chsten Schritt neu geboren. Lebende Zellen mit weniger als zwei lebenden Nachbarn sterben im n\u00e4chsten Schritt. Eine lebende Zelle mit zwei oder drei lebenden Nachbarn bleibt im n\u00e4chsten Schritt am Leben. Lebende Zellen mit mehr als drei lebenden Nachbarn sterben im n\u00e4chsten Schritt an \u00dcberbev\u00f6lkerung. Die Nachbarn f\u00fcr eine Zelle sind alle direkten , sowie die diagonalen Nachbarn. Umsetzung \u00b6 Schritt 1: Zellen \u00b6 Ein guter Punkt um zu starten ist eine Klasse f\u00fcr die Zellen zu schreiben, aus denen der Automat besteht. Diese brauchen mindestens diese Attribute: Der aktuelle Zustand Die Position der Zelle An Funktionen braucht die Klasse eigentlich nur eine Funktion void checknext(int nachbarn) , die den n\u00e4chsten Zustand der Zelle bestimmt, wen man ihr die Anzahl der lebendigen Nachbarn gibt. Beachte, dass der Zustand der Zelle erst ge\u00e4ndert werden darf, wenn der n\u00e4chste Zustand f\u00fcr alle Zellen berechnet wurde. Schritt 2: Automat \u00b6 Als n\u00e4chstes kann man schon den Automat schreiben. Dieser braucht nat\u00fcrlich ein Feld aus Zellen, das den aktuellen Zustand darstellt. Zus\u00e4tzlich braucht er Funktionen, die \u00fcber das ganze Feld iterieren um den n\u00e4chsten Schritt vorzubereiten: void prepareNextStep() und eine Funktion um die \u00c4nderungen auszuf\u00fchren: void executeNextStep() . Au\u00dferdem ist die Funktion int getNeighbors(COORD pos) n\u00f6tig, um die Lebendigen Nachbarn einer Zelle zu berechnen. Beachte, dass ein Verhalten f\u00fcr den Rand des (endlichen) Feldes festgelegt werden muss. Schritt 3: Dateiformat \u00b6 Die wichtigsten Teile des Automaten sind jetzt vorhanden. Als n\u00e4chstes m\u00fcssen wir uns Gedanken \u00fcber das Dateiformat machen, mit dem wir einen Zustand einlesen und dann wieder abspeichern wollen. Meine L\u00f6sung verwendet kein Format dass das ganze Feld abbildet, sondern nur die Koordinaten der lebenden Zellen speichert. Die 2-D Darstellung wird erst sichtbar, wenn man die Datei einliest. Es sind nat\u00fcrlich viel andere Formate m\u00f6glich. Schritt 4: Parser \u00b6 Nachdem wir das Format festgelegt habe, m\u00fcssen wir eigentlich nur noch den Parser schreiben, der die Datei einlesen kann und auch wieder in eine Datei schreiben kann. Diese Funktionen k\u00f6nnen einfach Teil der Automat Klasse, da diese direkt auf dem Feld arbeiten m\u00fcssen. In der L\u00f6sung sind das bool loadLayout(std::string filename) und void saveLayout(std::string filename) . In der L\u00f6sung gibt es die M\u00f6glichkeit zu pausieren, Zellen einzeln zu setzen, eine Anzahl an Schritten weiterzugehen und nat\u00fcrlich zu Speichern und zu Laden. Bedienung der L\u00f6sung \u00b6 Beim Starten bekommt man 3 verschiedene Optionen: Zustand aus einer Datei laden. Zuf\u00e4llige Ausgangssituation Die Zellen per Hand setzen Danach gibt es zwei Eingabe Modi mit den folgenden Optionen: Pausiert: T: Pause aufheben Q: Datei speichern O: Datei Laden WASD: Bewegen des Cursors Space: Zustand der Zelle setzten 1-9: L\u00e4sst den Automaten 1-9 Schritte weiter gehen Running: T: Pausieren S: Beende das Programm Es liegen schon ein paar Dateien mit interessanten Formationen in dem Verzeichnis \"start\" zum Beispiel f\u00fchrt zu einem gleichm\u00e4\u00dfigen Muster, das sich \u00fcber viele Schritte ausbreitet.","title":"Game of Life Kata"},{"location":"Conway/#game-of-life-kata","text":"Link zur Kata hier . Bei der Game of Life Kata geht es darum, Conways \"Game of Life\" nachzuprogrammieren, einen Startzustand laden zu k\u00f6nnen und den n\u00e4chsten Zustand wieder abspeichern zu k\u00f6nnen. Das \"Game of Life\" ist ein spezifischer Zellul\u00e4rer Automat , also kurzgesagt ein 2-Dimensionales (nicht zwingend) Feld aus Zellen, die bin\u00e4r entweder tot (0) oder lebendig (1) sind. Zus\u00e4tzlich haben zellul\u00e4rer Automaten eine Regel, die festlegt, welchen Zustand die Zelle im n\u00e4chsten Schritt haben wird. Diese Regel ist immer abh\u00e4ngig von den Nachbarn einer Zelle.","title":"Game of Life Kata"},{"location":"Conway/#conways-game-of-life","text":"Das \"Game of Life\" hat seinen Namen daher, dass die Regel des Automaten ein Ergebnis liefert, dass stark an die Bewegung und Entwicklung von kleinen mehrzelligen Organismen erinnert. Es gibt sich wiederholende, sich bewegende und konstante Muster. Die Regeln des \"Game of Life\" sind ganz einfach: Eine tote Zelle mit genau drei lebenden Nachbarn wird im n\u00e4chsten Schritt neu geboren. Lebende Zellen mit weniger als zwei lebenden Nachbarn sterben im n\u00e4chsten Schritt. Eine lebende Zelle mit zwei oder drei lebenden Nachbarn bleibt im n\u00e4chsten Schritt am Leben. Lebende Zellen mit mehr als drei lebenden Nachbarn sterben im n\u00e4chsten Schritt an \u00dcberbev\u00f6lkerung. Die Nachbarn f\u00fcr eine Zelle sind alle direkten , sowie die diagonalen Nachbarn.","title":"Conways Game of Life"},{"location":"Conway/#umsetzung","text":"","title":"Umsetzung"},{"location":"Conway/#schritt-1-zellen","text":"Ein guter Punkt um zu starten ist eine Klasse f\u00fcr die Zellen zu schreiben, aus denen der Automat besteht. Diese brauchen mindestens diese Attribute: Der aktuelle Zustand Die Position der Zelle An Funktionen braucht die Klasse eigentlich nur eine Funktion void checknext(int nachbarn) , die den n\u00e4chsten Zustand der Zelle bestimmt, wen man ihr die Anzahl der lebendigen Nachbarn gibt. Beachte, dass der Zustand der Zelle erst ge\u00e4ndert werden darf, wenn der n\u00e4chste Zustand f\u00fcr alle Zellen berechnet wurde.","title":"Schritt 1: Zellen"},{"location":"Conway/#schritt-2-automat","text":"Als n\u00e4chstes kann man schon den Automat schreiben. Dieser braucht nat\u00fcrlich ein Feld aus Zellen, das den aktuellen Zustand darstellt. Zus\u00e4tzlich braucht er Funktionen, die \u00fcber das ganze Feld iterieren um den n\u00e4chsten Schritt vorzubereiten: void prepareNextStep() und eine Funktion um die \u00c4nderungen auszuf\u00fchren: void executeNextStep() . Au\u00dferdem ist die Funktion int getNeighbors(COORD pos) n\u00f6tig, um die Lebendigen Nachbarn einer Zelle zu berechnen. Beachte, dass ein Verhalten f\u00fcr den Rand des (endlichen) Feldes festgelegt werden muss.","title":"Schritt 2: Automat"},{"location":"Conway/#schritt-3-dateiformat","text":"Die wichtigsten Teile des Automaten sind jetzt vorhanden. Als n\u00e4chstes m\u00fcssen wir uns Gedanken \u00fcber das Dateiformat machen, mit dem wir einen Zustand einlesen und dann wieder abspeichern wollen. Meine L\u00f6sung verwendet kein Format dass das ganze Feld abbildet, sondern nur die Koordinaten der lebenden Zellen speichert. Die 2-D Darstellung wird erst sichtbar, wenn man die Datei einliest. Es sind nat\u00fcrlich viel andere Formate m\u00f6glich.","title":"Schritt 3: Dateiformat"},{"location":"Conway/#schritt-4-parser","text":"Nachdem wir das Format festgelegt habe, m\u00fcssen wir eigentlich nur noch den Parser schreiben, der die Datei einlesen kann und auch wieder in eine Datei schreiben kann. Diese Funktionen k\u00f6nnen einfach Teil der Automat Klasse, da diese direkt auf dem Feld arbeiten m\u00fcssen. In der L\u00f6sung sind das bool loadLayout(std::string filename) und void saveLayout(std::string filename) . In der L\u00f6sung gibt es die M\u00f6glichkeit zu pausieren, Zellen einzeln zu setzen, eine Anzahl an Schritten weiterzugehen und nat\u00fcrlich zu Speichern und zu Laden.","title":"Schritt 4: Parser"},{"location":"Conway/#bedienung-der-losung","text":"Beim Starten bekommt man 3 verschiedene Optionen: Zustand aus einer Datei laden. Zuf\u00e4llige Ausgangssituation Die Zellen per Hand setzen Danach gibt es zwei Eingabe Modi mit den folgenden Optionen: Pausiert: T: Pause aufheben Q: Datei speichern O: Datei Laden WASD: Bewegen des Cursors Space: Zustand der Zelle setzten 1-9: L\u00e4sst den Automaten 1-9 Schritte weiter gehen Running: T: Pausieren S: Beende das Programm Es liegen schon ein paar Dateien mit interessanten Formationen in dem Verzeichnis \"start\" zum Beispiel f\u00fchrt zu einem gleichm\u00e4\u00dfigen Muster, das sich \u00fcber viele Schritte ausbreitet.","title":"Bedienung der L\u00f6sung"},{"location":"Programmieren/","text":"Coding-\u00dcbungen \u00b6 Hier finden sie eine kleine Zusammenstellung von Coding-\u00dcbungen, die ich privat oder im Rahmen meines Studiums angelegt habe. \"Rouge\" Clone \u00b6 Dieses kleine Konsolen basierte Spiel hab ich mit C++ geschrieben. Das Level und die R\u00e4ume werden prozedural generiert . Es gibt eine Gegner-KI und eine interaktive Karte. F\u00fcr Elemente, die sich nicht gut mit Schriftzeichen umsetzen lasen, habe ich einen Font erstellt. Die Karte besteht aus abge\u00e4nderten Schriftzeichen Game Engines \u00b6 In verschiedenen Veranstaltungen haben wir die Grundlagen von Unity, Unreal und Vektoria kennengelernt und eigene Projekte umgesetzt. Im aktuellen Semester setzen wir einen Character mit Motion-Capture in der Unreal Engine um. Bewegung eines Characters mit Nav-Mesh Computer-Grafik \"Zu Fu\u00df\" \u00b6 In verschiedenen Vorlesungen haben wir grundlegenden Elemente der Computer-Grafik programmiert. Dabei haben wir mit OpenGLSL Shader programmiert und QT kennengelernt. Farbverl\u00e4ufe durch rekursive Aufrufe Visualisierung der Mandelbrot Menge Zuf\u00e4llige Farben und dennoch kontinuierliche Farbverl\u00e4ufe Kreis aus Zellen mit \"3D Effekt\" Shader Programmierung mit OpenGLSL Fragment Shader in action Zellul\u00e4rer Automat \u00b6 Eine einfache Umsetzung von Conways \"Game-of-Life\" mit der M\u00f6glichkeit, Zust\u00e4nde zu laden und zu speichern. Umgesetzt auf der Konsole mit C++. Schritt 1 Schritt 2 Schritt 3 Schritt 4","title":"4. Coding-\u00dcbungen"},{"location":"Programmieren/#coding-ubungen","text":"Hier finden sie eine kleine Zusammenstellung von Coding-\u00dcbungen, die ich privat oder im Rahmen meines Studiums angelegt habe.","title":"Coding-\u00dcbungen"},{"location":"Programmieren/#rouge-clone","text":"Dieses kleine Konsolen basierte Spiel hab ich mit C++ geschrieben. Das Level und die R\u00e4ume werden prozedural generiert . Es gibt eine Gegner-KI und eine interaktive Karte. F\u00fcr Elemente, die sich nicht gut mit Schriftzeichen umsetzen lasen, habe ich einen Font erstellt. Die Karte besteht aus abge\u00e4nderten Schriftzeichen","title":"\"Rouge\" Clone"},{"location":"Programmieren/#game-engines","text":"In verschiedenen Veranstaltungen haben wir die Grundlagen von Unity, Unreal und Vektoria kennengelernt und eigene Projekte umgesetzt. Im aktuellen Semester setzen wir einen Character mit Motion-Capture in der Unreal Engine um. Bewegung eines Characters mit Nav-Mesh","title":"Game Engines"},{"location":"Programmieren/#computer-grafik-zu-fu","text":"In verschiedenen Vorlesungen haben wir grundlegenden Elemente der Computer-Grafik programmiert. Dabei haben wir mit OpenGLSL Shader programmiert und QT kennengelernt. Farbverl\u00e4ufe durch rekursive Aufrufe Visualisierung der Mandelbrot Menge Zuf\u00e4llige Farben und dennoch kontinuierliche Farbverl\u00e4ufe Kreis aus Zellen mit \"3D Effekt\" Shader Programmierung mit OpenGLSL Fragment Shader in action","title":"Computer-Grafik \"Zu Fu\u00df\""},{"location":"Programmieren/#zellularer-automat","text":"Eine einfache Umsetzung von Conways \"Game-of-Life\" mit der M\u00f6glichkeit, Zust\u00e4nde zu laden und zu speichern. Umgesetzt auf der Konsole mit C++. Schritt 1 Schritt 2 Schritt 3 Schritt 4","title":"Zellul\u00e4rer Automat"},{"location":"Skizzen/","text":"Gestalten und Zeichnen \u00b6","title":"Gestalten und Zeichnen"},{"location":"Skizzen/#gestalten-und-zeichnen","text":"","title":"Gestalten und Zeichnen"},{"location":"Sonstiges/","text":"Sonstige Projekte \u00b6 Hier finden sie eine kleine Zusammenstellung anderer Projekte. Webseite Projekt \"Alpencross\" \u00b6 Die Webseite wurde von mir im Rahmen des P-Seminars \"Alpencross\" mit Jimdoo erstellt. Ziel des Seminars war es, mit dem Mountainbike in 7 Tagen von M\u00fcnchen zum Gardasee zu fahren. Die Webseite der \"Hoehen Heroes\" Skizzen \u00b6 Im 2. Semester habe ich im Rahmen der Veranstaltung \"Gestalten und Zeichnen\", ein Portfolio mit Bleistift Skizzen angelegt, um ein grundlegendes Verst\u00e4ndnis f\u00fcr gestalterische Aspekte aufzubauen. Portraits zweier Comic-Figuren Weitere Video Projekte \u00b6 Neben dem bereits erw\u00e4hnten Videoprojekt \"Mikado-Tower\", habe ich auch f\u00fcr andere Projekte die Erstellung eines Videos \u00fcbernommen. Beispiele: Die Videos f\u00fcr Alpencross und XClimb . Endcard des XClimb Videos Custom-Content f\u00fcr Spiele \u00b6 F\u00fcr verschiedene Spiele habe ich mit den mitgelieferten Editoren, Custom-Content wie Karten erstellt. Zum Beispiel meine \"Company of Heroes 2\" Karte \"Derailed\" : CoH2 Karte \"Derailed\" Wargroove Szenario","title":"5. Sonstige Projekte"},{"location":"Sonstiges/#sonstige-projekte","text":"Hier finden sie eine kleine Zusammenstellung anderer Projekte.","title":"Sonstige Projekte"},{"location":"Sonstiges/#webseite-projekt-alpencross","text":"Die Webseite wurde von mir im Rahmen des P-Seminars \"Alpencross\" mit Jimdoo erstellt. Ziel des Seminars war es, mit dem Mountainbike in 7 Tagen von M\u00fcnchen zum Gardasee zu fahren. Die Webseite der \"Hoehen Heroes\"","title":"Webseite Projekt \"Alpencross\""},{"location":"Sonstiges/#skizzen","text":"Im 2. Semester habe ich im Rahmen der Veranstaltung \"Gestalten und Zeichnen\", ein Portfolio mit Bleistift Skizzen angelegt, um ein grundlegendes Verst\u00e4ndnis f\u00fcr gestalterische Aspekte aufzubauen. Portraits zweier Comic-Figuren","title":"Skizzen"},{"location":"Sonstiges/#weitere-video-projekte","text":"Neben dem bereits erw\u00e4hnten Videoprojekt \"Mikado-Tower\", habe ich auch f\u00fcr andere Projekte die Erstellung eines Videos \u00fcbernommen. Beispiele: Die Videos f\u00fcr Alpencross und XClimb . Endcard des XClimb Videos","title":"Weitere Video Projekte"},{"location":"Sonstiges/#custom-content-fur-spiele","text":"F\u00fcr verschiedene Spiele habe ich mit den mitgelieferten Editoren, Custom-Content wie Karten erstellt. Zum Beispiel meine \"Company of Heroes 2\" Karte \"Derailed\" : CoH2 Karte \"Derailed\" Wargroove Szenario","title":"Custom-Content f\u00fcr Spiele"},{"location":"Stjarna/","text":"Brettspiel Projekt \"Stjarna\" \u00b6 \"Stjarna\" ist ein von mir entworfenes Brettspiel, in dem 5 Spieler versuchen, m\u00f6glichst viele ihrer Mitspieler zu unterwerfen und so zum \"K\u00f6nig des Nordens aufzusteigen. Wer sich durchsetzen will muss geschickt verhandeln, schlau taktieren und darf keine Skrupel zeigen. \u00dcber \"Stjarna\" \u00b6 In Stjarna dreht sich alles um die Interaktion der 5 Spieler unter- und miteinander. Spieler bekommen Punkte pro Runde entsprechend ihrer Position in einem Gefolge und k\u00e4mpfen darum, einen m\u00f6glichst hohen Rang zu bekleiden. Um ihre Ziele zu erreichen, k\u00f6nnen sie Karten und Ressourcen einsetzen um durch Diplomatie oder Gewalt eine hohe Position zu erreichen. Dabei haben die Anf\u00fchrer eines Gefolges aber nicht nur Vorteile! Man muss sich entscheiden, ob man gleich los st\u00fcrmt oder doch eine g\u00fcnstigeren Moment abwartet. Die Anleitung finden Sie hier . Stjarna ist altnordisch f\u00fcr Stern. Es spielt in Skandinavien um das Jahr 1000, die Zeit der ersten D\u00e4nischen K\u00f6nige, gro\u00dfer K\u00e4mpfe um die Herrschaft \u00fcber Skandinavien und dem Beginn der Christianisierung. Die Spieler schl\u00fcpfen in die Rolle eines historischen nordischen Anf\u00fchrers. Einige Aufmerksame d\u00fcrften Harald Blauzahns Rune wiedererkennen (Bluetooth), der durch seine diplomatischen F\u00e4higkeiten ber\u00fchmt wurde und deswegen Namensgeber f\u00fcr den modernen drahtlosen Kommunikationsstandard ist. Manche der Karten spielen auf historische Ereignisse an.","title":"1. Brettspiel \"Stjarna\""},{"location":"Stjarna/#brettspiel-projekt-stjarna","text":"\"Stjarna\" ist ein von mir entworfenes Brettspiel, in dem 5 Spieler versuchen, m\u00f6glichst viele ihrer Mitspieler zu unterwerfen und so zum \"K\u00f6nig des Nordens aufzusteigen. Wer sich durchsetzen will muss geschickt verhandeln, schlau taktieren und darf keine Skrupel zeigen.","title":"Brettspiel Projekt \"Stjarna\""},{"location":"Stjarna/#uber-stjarna","text":"In Stjarna dreht sich alles um die Interaktion der 5 Spieler unter- und miteinander. Spieler bekommen Punkte pro Runde entsprechend ihrer Position in einem Gefolge und k\u00e4mpfen darum, einen m\u00f6glichst hohen Rang zu bekleiden. Um ihre Ziele zu erreichen, k\u00f6nnen sie Karten und Ressourcen einsetzen um durch Diplomatie oder Gewalt eine hohe Position zu erreichen. Dabei haben die Anf\u00fchrer eines Gefolges aber nicht nur Vorteile! Man muss sich entscheiden, ob man gleich los st\u00fcrmt oder doch eine g\u00fcnstigeren Moment abwartet. Die Anleitung finden Sie hier . Stjarna ist altnordisch f\u00fcr Stern. Es spielt in Skandinavien um das Jahr 1000, die Zeit der ersten D\u00e4nischen K\u00f6nige, gro\u00dfer K\u00e4mpfe um die Herrschaft \u00fcber Skandinavien und dem Beginn der Christianisierung. Die Spieler schl\u00fcpfen in die Rolle eines historischen nordischen Anf\u00fchrers. Einige Aufmerksame d\u00fcrften Harald Blauzahns Rune wiedererkennen (Bluetooth), der durch seine diplomatischen F\u00e4higkeiten ber\u00fchmt wurde und deswegen Namensgeber f\u00fcr den modernen drahtlosen Kommunikationsstandard ist. Manche der Karten spielen auf historische Ereignisse an.","title":"\u00dcber \"Stjarna\""},{"location":"XClimb/","text":"Spielprojekt \"XClimb\" \u00b6 XClimb ist im 3. Semester als Projekt einer Siebenk\u00f6pfigen Studentengruppe entstanden. Ziel war es, mit der \"Vektoria Engine\" und kleinen tragbaren Bewegungssensoren ein Bewegungsspiel zu erstellen. In dem Projekt hab ich einen gro\u00dfen Teil der Programmierung, sowie die Einbindung der Sensoren \u00fcbernommen. Zus\u00e4tzlich habe ich das Game-Design Dokument f\u00fcr das Projekt geschrieben. \u00dcber XClimb \u00b6 XClimb ist ein vom Speed-Climbing inspiriertes Bewegungsspiel, bei dem zwei Spieler im direkten Wettkampf gegeneinander antreten, um als erstes ganz oben anzukommen. Screenshot von \"XClimb\" Test des Bewegungssensors Video-Pr\u00e4sentation \u00b6 Mehr Einblicke finden Sie hier .","title":"2. Spielprojekt XClimb"},{"location":"XClimb/#spielprojekt-xclimb","text":"XClimb ist im 3. Semester als Projekt einer Siebenk\u00f6pfigen Studentengruppe entstanden. Ziel war es, mit der \"Vektoria Engine\" und kleinen tragbaren Bewegungssensoren ein Bewegungsspiel zu erstellen. In dem Projekt hab ich einen gro\u00dfen Teil der Programmierung, sowie die Einbindung der Sensoren \u00fcbernommen. Zus\u00e4tzlich habe ich das Game-Design Dokument f\u00fcr das Projekt geschrieben.","title":"Spielprojekt \"XClimb\""},{"location":"XClimb/#uber-xclimb","text":"XClimb ist ein vom Speed-Climbing inspiriertes Bewegungsspiel, bei dem zwei Spieler im direkten Wettkampf gegeneinander antreten, um als erstes ganz oben anzukommen. Screenshot von \"XClimb\" Test des Bewegungssensors","title":"\u00dcber XClimb"},{"location":"XClimb/#video-prasentation","text":"Mehr Einblicke finden Sie hier .","title":"Video-Pr\u00e4sentation"},{"location":"XClimb_Pictures/","text":"Das Layout der Wand ist prozedural generiert Das Spieler Modell in Blender Ein Test des Bewegungssensors Die movANALYZE Software Die Struktur des Codes Auszug aus dem GDD","title":"XClimb Pictures"},{"location":"XClimb_Video/","text":"","title":"XClimb Video"}]}